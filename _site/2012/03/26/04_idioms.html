<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title></title>
	<meta name="description" content="">
	<meta name="author" content="">

	<meta name="viewport" content="width=device-width">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/highlight.css">
	<link rel="stylesheet" href="/css/custom.css">

	<script src="/js/libs/modernizr-2.5.3.min.js"></script>
</head>
<body class="gray">
<header>
</header>
<div role="main" id="main">
	<div class="post">
	<div class='back'><a href='/tlboc.html'>&laquo; 返回目录</a></div>
<h1 id='coffeescript'>CoffeeScript惯用法</h1>

<p>每个语言都有自己的惯用法和最佳实践，CoffeeScript也不例外。本章将为你揭示这些常规的东西，并且为你指出一些JavaScript到CoffeeScript的变化，以便你对这门语言有个感性的认识。</p>

<h2 id='each'>Each</h2>

<p>在JavaScript中我们既可以使用新加入的<a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach'><code>forEach()</code></a>也可以使用老的C语言风格的<code>for</code>循环来迭代一个数组。如果你打算使用一些在ECMAScript 5 提到的JavaScript新特性的话，我推荐你把这个 <a href='https://github.com/kriskowal/es5-shim'>shim</a> （薄层）来模拟这些特性以便支持老的浏览器。</p>

<pre><code>for (var i=0; i &lt; array.length; i++)
  myFunction(array[i]);
  
array.forEach(function(item, i){
  myFunction(item)
});</code></pre>

<p>尽管<code>forEach()</code>语法非常简洁易读，但有个缺点是在每次数组迭代时都需要调用回调函数，因此它比等价的<code>for</code>循环要慢。让我看一下这CoffeeScirpt中又是什么样子。</p>
<span class='csscript' />
<pre><code>myFunction(item) for item in array</code></pre>

<p>这种语法易读简洁（我想你也这么认为），而且更棒的是这在背后会被编译为<code>for</code>循环。换句话说CoffeeScript的语法提供了<code>forEach()</code>的便捷，但是没有性能的损耗，也不需要shim的辅助。</p>

<h2 id='map'>Map</h2>

<p>与<code>forEach()</code>相同，ES5包含了一个比经典<code>for</code>循环在语法上更加简洁的函数，名为 <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map'><code>map()</code></a>。不过它与<code>forEach()</code>有一样需要注意的地方，其运行速度仍会受到函数调用的拖累。</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});</code></pre>

<p>如我们在<em>语法</em>这一章所说，可以使用列表解析获得与<code>map()</code>同样的行为。注意最好使用括号把列表解析包裹起来，以便能够<strong>完全地</strong>确保列表解析返回你所想要的东西——映射后的数组。</p>
<span class='csscript' />
<pre><code>result = (item.name for item in array)</code></pre>

<h2 id='id17'>筛选</h2>

<p>ES5还提供了工具函数 <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter'><code>filter()</code></a> 来过滤数组：</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  if (array[i].name == &quot;test&quot;)
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == &quot;test&quot;
});</code></pre>

<p>CoffeeScript的基础语法使用<code>when</code>关键字通过一个比较来过滤数组项。在背后会产生一个<code>for</code>循环，整个运行过程都包裹在一个匿名函数中，以防止作用域泄漏或变量冲突。</p>
<span class='csscript' />
<pre><code>result = (item for item in array when item.name is &quot;test&quot;)</code></pre>

<p>别忘了使用括号，否则<code>result</code>是数组的最后一项。<br />CoffeeScript的列表解析是如此的灵活，允许你如下例这样做出强大地选择：</p>
<span class='csscript' />
<pre><code>passed = []
failed = []
(if score &gt; 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score &gt; 60)</code></pre>

<p>如果列表解析太长，你可以将它们分割成多行。</p>
<span class='csscript' />
<pre><code>passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score &gt; 60 then passed else failed).push score</code></pre>

<h2 id='id18'>包含</h2>

<p>通常使用<code>indexOf()</code>来测试一个数组中是否包含某个值。不过真让人惊讶, Internet Explorer并没有实现该函数，这还要做一些兼容。</p>

<pre><code>var included = (array.indexOf(&quot;test&quot;) != -1)</code></pre>

<p>于此CoffeeScript有一个非常给力的替代方法，Python程序员一定很熟悉，名叫<code>in</code>。</p>
<span class='csscript' />
<pre><code>included = &quot;test&quot; in array</code></pre>

<p>在背后，CoffeeScript使用的是 <code>Array.prototype.indexOf()</code>，必要的话提供shim方法来检测数组中是否有某个特定值，不幸的的是同样的<code>in</code>语法并不能在字符串中工作。我们退回去使用<code>indexOf()</code>函数，查看其返回值是否是负值：</p>
<span class='csscript' />
<pre><code>included = &quot;a long test string&quot;.indexOf(&quot;test&quot;) isnt -1</code></pre>

<p>或者更好一点，借助于位操作符我们就不用与<code>-1</code>进行比较了。</p>
<span class='csscript' />
<pre><code>string   = &quot;a long test string&quot;
included = !!~ string.indexOf &quot;test&quot;</code></pre>

<h2 id='id19'>属性迭代</h2>

<p>在JavaScript中，你应该使用<code>in</code>操作符来迭代属性集，例如：</p>

<pre><code>var object = {one: 1, two: 2}
for(var key in object) alert(key + &quot; = &quot; + object[key])</code></pre>

<p>然而，如你在上一小节所知，CoffeeScript已把<code>in</code>关键字留给了数组用。作为替代，该操作符更名为<code>of</code>，可以像下面这样用：</p>
<span class='csscript' />
<pre><code>object = {one: 1, two: 2}
alert(&quot;#{key} = #{value}&quot;) for key, value of object</code></pre>

<p>如你所见，你可以同时指定属性名和属性值，非常方便。</p>

<h2 id='minmax'>Min/Max</h2>

<p>这个技巧虽然不是CoffeeScript的专利，但是我觉得它非常有用，值得一提。<code>Math.max</code> 和<code>Math.min</code>接受多个参数，因此你可以简单的地使用<code>...</code>来向它们传递数组，从中检索出最大值和最小值。</p>
<span class='csscript' />
<pre><code>Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7</code></pre>

<p>请注意，这个技巧对于超大的数组也会失败，因为浏览器对传递个函数的参数数量有限制。</p>

<h2 id='id20'>多个参数</h2>

<p>在上面的<code>Math.max</code>示例中，我们使用<code>...</code>来结构数组作为多个参数传递给<code>max</code>方法。在背后，CoffeeScript将其转化为一个使用<code>appply()</code>的函数调用，以确保数组能够作为多个参数传递给<code>max</code>。在别的地方也可以使用这个特性，比方说代理函数：</p>
<span class='csscript' />
<pre><code>Log =
  log: -&gt;
    console?.log(arguments...)</code></pre>

<p>或者在参数继续传递下去之前，修改参数：</p>
<span class='csscript' />
<pre><code>Log =
  logPrefix: &quot;(App)&quot;

  log: (args...) -&gt;
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)</code></pre>

<p>不过请记住，CoffeeScript会自动把函数的调用上下文设置为调用它的对象。在上例中，就是<code>console</code>对象，如果你想设置特殊的上下文，那你需要手动的调用<code>apply()</code>方法。</p>

<h2 id='andor'>And/or</h2>

<p>CoffeeScript编程风格推荐使用<code>or</code>代替<code>||</code>，使用<code>and</code>代替<code>&amp;&amp;</code>。我知道为什么，因为前者看起来更直观。不过，这两种编程风格产生的结果都一样。</p>

<p>偏爱英语风格的代码的话，也可以使用<code>is</code>代替<code>==</code>，<code>isnt</code>代替<code>!=</code>。</p>
<span class='csscript' />
<pre><code>string = &quot;migrating coconuts&quot;
string == string # true
string is string # true</code></pre>

<p>CoffeeScript还有另外一个非常好的扩展，Ruby程序员可将其看作像是<code>||=</code>这样的模式：</p>
<span class='csscript' />
<pre><code>hash or= {}</code></pre>

<p>如果<code>hash</code>求值为<code>false</code>，则把它设置为一个空对象。在这里需要注意，表达式<code>0</code>、<code>&quot;&quot;</code>和<code>null</code>都会被当作<code>false</code>。如果这并不是你想要的，那你应该使用CoffeeScript的存在操作符，这样只有<code>hash</code>是<code>undefined</code>或者<code>null</code>时才会触发。</p>
<span class='csscript' />
<pre><code>hash ?= {}</code></pre>

<h2 id='id21'>解构赋值</h2>

<p>解构赋值对任意深度嵌套的数组或对象都适用，方便从嵌套的属性中抽取值。</p>
<span class='csscript' />
<pre><code>someObject = { a: &#39;value for a&#39;, b: &#39;value for b&#39; }
{ a, b } = someObject
console.log &quot;a is &#39;#{a}&#39;, b is &#39;#{b}&#39;&quot;</code></pre>

<p>这在Node程序中引入模块时尤其有用：</p>
<span class='csscript' />
<pre><code>{join, resolve} = require(&#39;path&#39;)

join(&#39;/Users&#39;, &#39;Alex&#39;)</code></pre>

<h2 id='id22'>其他类库</h2>

<p>既然所有的东西都会编译为JavaScript，那么使用其他类库与调用CoffeeScript类库的函数并没有什么差别。在CoffeeScript中使用 <a href='http://jquery.com'>jQuery</a>显得非常优雅，因为jQuery的API中有很多回调函数。</p>
<span class='csscript' />
<pre><code># Use local alias
$ = jQuery

$ -&gt;
  # DOMContentLoaded
  $(&quot;.el&quot;).click -&gt;
    alert(&quot;Clicked!&quot;)</code></pre>

<p>既然CoffeeScript编译输出的所有代码都被包裹在一个匿名函数中，因此我们可以使用一个局部变量<code>$</code>来代替<code>jQuery</code>。就算在jQuery的<code>no confict</code>模式或者<code>$</code>被重定义的情况下，我们的脚本能按预想的一样正常工作。</p>

<h2 id='id23'>私有变量</h2>

<p>CoffeeScript中的<code>do</code>关键字能够让我们立即运行函数，这是一种非常有效的包装作用域和受保护变量的方式。在下面的例子中，我在被<code>do</code>立刻调用的匿名函数的上下文中定义了一个变量<code>classToType</code>。该匿名函数返回了另外一个匿名函数，它才是<code>type</code>最终的值。既然<code>classType</code>是在一个不保存引用的上下文中，因此在外部作用域中不可访问。</p>
<span class='csscript' />
<pre><code># Execute function immediately
type = do -&gt;
  classToType = {}
  for name in &quot;Boolean Number String Function Array Date RegExp Undefined Null&quot;.split(&quot; &quot;)
    classToType[&quot;[object &quot; + name + &quot;]&quot;] = name.toLowerCase()
  
  # Return a function
  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or &quot;object&quot;</code></pre>

<p>换句话说，<code>classToType</code>是完全私有的，并且在匿名函数执行完毕之后就不能在外面作用域中引用它了。这是一种非常好的包装作用域和变量的办法。</p>	
<div>

</div>
<footer>
</footer>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/libs/jquery-1.7.1.min.js"><\/script>')</script>

<!-- scripts concatenated and minified via ant build script-->
<script src="/js/plugins.js"></script>
<script src="/js/script.js"></script>
<!-- end scripts-->

<script>
	var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
	(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
	g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
	s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>
